NAMESPACE = authkit-demo

.PHONY: up down restart logs-authelia logs-caddy logs-dagster build-dagster connect

all: up

# 1. Builda a imagem
build:
	@echo "ğŸ—ï¸  [1/3] Buildando imagem do Dagster (contexto local)..."
	@eval $$(minikube docker-env) && docker build -t dagster-authkit:local --build-arg EXTRAS=sqlite ../../

# 2. Sobe toda a infraestrutura
up:
	@echo "ğŸš€ [2/3] Subindo infraestrutura no Kubernetes..."
	# Garante que o namespace existe
	@kubectl create namespace $(NAMESPACE) --dry-run=client -o yaml | kubectl apply -f -
	
	@echo "ğŸ—„ï¸  Subindo LDAP..."
	@kubectl apply -f k8s/ldap/
	
	@echo "ğŸ›¡ï¸  Subindo Authelia..."
	@kubectl apply -f k8s/authelia/

	@echo "ğŸ“Š Subindo Dagster..."
	@kubectl apply -f k8s/dagster/
	
	@echo "ğŸŒ Subindo Caddy (LoadBalancer)..."
	@kubectl apply -f k8s/caddy/
	
	@echo ""
	@echo "âœ… Build e Deploy finalizados!"
	@echo "âš ï¸  PRÃ“XIMO PASSO OBRIGATÃ“RIO:"
	@echo "   Abra OUTRO terminal e rode: make connect"
	@echo ""

# 3. O comando que faltava: O TÃºnel de Rede
connect:
	@echo "ğŸ”Œ Iniciando tÃºnel de rede (precisa de sudo)..."
	@echo "ğŸ›‘ Mantenha este terminal aberto!"
	@minikube tunnel

down:
	@echo "ğŸ”¥ Destruindo tudo..."
	kubectl delete namespace $(NAMESPACE)

restart:
	@echo "â™»ï¸  Reiniciando deployments..."
	kubectl rollout restart deployment -n $(NAMESPACE)

# Logs
logs-authelia:
	kubectl logs -l app=authelia -n $(NAMESPACE) -f
logs-caddy:
	kubectl logs -l app=caddy -n $(NAMESPACE) -f
logs-dagster:
	kubectl logs -l app=dagster -n $(NAMESPACE) -f